[{"id":"e6d4f3856fb126d0","type":"subflow","name":"Subflow 1","info":"","in":[],"out":[]},{"id":"b6cca5690610775e","type":"ha-get-entities","z":"e6d4f3856fb126d0","name":"","server":"b1ec8b7d.9fa258","version":1,"rules":[{"condition":"device_registry","property":"model","logic":"starts_with","value":"DW1000","valueType":"str"}],"outputType":"array","outputEmptyResults":false,"outputLocationType":"msg","outputLocation":"payload","outputResultsCount":1,"x":530,"y":580,"wires":[["e76639ef87e83b38"]]},{"id":"2cb2b96cab6bcdf6","type":"function","z":"e6d4f3856fb126d0","name":"Extract distances related to tag","func":"const TAG_ID = `dw1000-tag-${env.get(\"TAG_MAC\")}`;\n\n\n/*const relatedMeasurements = msg.payload.filter(({attributes: {friendly_name, device_class}, timeSinceChangedMs}) => \n    friendly_name.startsWith(TAG_ID) && \n    device_class == \"distance\" &&\n    timeSinceChangedMs < 2000);*/\nconst relatedMeasurements = msg.payload.reduce((acc, curr) => {\n    const isDistance = curr.entity_id.endsWith(\"dist\");\n    const isRecent = curr.timeSinceChangedMs < 5000;\n    if(isDistance && isRecent) {\n\n        // extract mac address from the entity id\n        const tag = curr.entity_id.slice(-29).slice(0, 12) // tag\n        const mac = curr.entity_id.slice(-16).slice(0,12) // anchor\n\n        acc[mac] =  {...acc[mac], [tag]: parseFloat(curr.state)}\n    }\n\n    return acc;\n}, {})\n\nconst coordinates = msg.payload.reduce((acc, curr) => {\n\n    const axis = curr.entity_id.slice(-2);\n    const isAnchor = curr.entity_id.includes(\"anchor\");\n\n    if(isAnchor && (axis == \"_x\" || \n       axis == \"_y\" ||\n       axis == \"_z\")) {\n        // extract mac\n        const mac = curr.entity_id.split(\"_\")[2];\n        \n        acc[mac] = acc[mac] == null ? \n            {[axis.slice(-1)]: parseFloat(curr.state)} :\n            {...acc[mac], [axis.slice(-1)]: parseFloat(curr.state) }\n       }\n       return acc;\n}, {})\n\nconst tagCoordinates = msg.payload.reduce((acc, curr) => {\n\n    const axis = curr.entity_id.slice(-2);\n    const isTag = curr.entity_id.includes(\"tag\");\n\n    if (isTag && (axis == \"_x\" ||\n        axis == \"_y\" ||\n        axis == \"_z\")) {\n        // extract mac\n        const mac = curr.entity_id.split(\"_\")[2];\n\n        acc[mac] = acc[mac] == null ?\n            { [axis.slice(-1)]: parseFloat(curr.state) } :\n            { ...acc[mac], [axis.slice(-1)]: parseFloat(curr.state) }\n    }\n    return acc;\n}, {})\n\n\nconst grouped = Object.keys(relatedMeasurements).map(\n    (id) => {\n        if(coordinates[id] == null || relatedMeasurements[id] == null) {\n            return null;\n        }\n        \n        const coordsArr = Object.values(coordinates[id]);\n\n        if(coordsArr.length !== 3 || \n           coordsArr.every(c => isNaN(c))) {\n            return null;\n        }\n        return {\n            coordinates: coordinates[id],\n            distance: relatedMeasurements[id],\n        };\n        }).filter(c => c != null)\n\n//node.warn({msg, grouped, tagCoordinates, coordinates});\n\nreturn {anchors: grouped, tagCoordinates}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1030,"y":580,"wires":[["f90871e84fdda9b0"]]},{"id":"f90871e84fdda9b0","type":"function","z":"e6d4f3856fb126d0","name":"Calculate coordinates of tag","func":"\nconst LM = mlLevenbergMarquardt.levenbergMarquardt;\n\nconst TAG_MAC = env.get(\"TAG_MAC\");\n\nif(msg.anchors.length < 4) {\n    node.error({TAG_MAC, msg:\"less than 4 anchors, not stable solution\", anchors: msg.anchors});\n    // don't pass message if less than 3 nodes detected\n    return null;\n}\n\nconst anchors = msg.anchors.map((anchor) => [\n    anchor.coordinates.x,\n    anchor.coordinates.y,\n    anchor.coordinates.z,\n]);\n\n\n\n\n// Measured distances from each anchor\nconst distances = msg.anchors.map((anchor) => anchor.distance[TAG_MAC]);\n\n// Model function: Gives the summed distances from the point to the anchors\nconst modelFunction = (parameters) => {\n    const [x, y, z] = parameters;\n\n    return (anchorIndex) => {\n        const [ax, ay, az] = anchors[anchorIndex];\n        return Math.sqrt((x - ax) ** 2 + (y - ay) ** 2 + (z - az) ** 2);\n    };\n};\n\n// Independent variables: anchor indices (used in the model function)\nconst independentVars = anchors.map((_, index) => index);\n\n// Dependent variables: measured distances\nconst dependentVars = distances;\n\nconst tagCoordinates = msg.tagCoordinates[env.get(\"TAG_MAC\")];\n\nconst tagCoordInvalid = (coord) => {\n    return isNaN(coord)\n        || coord == 0\n        || coord == null\n        || coord < -1\n        || coord > 15;\n}\n\n\nif(tagCoordinates == null) {\n    // tag doesn't exist for some reason...\n    return null;\n}\n\n// Initial guess for (x, y, z)\n// average of the anchor coordinates except z which will be half the max to get it within the center of the volume\nvar initialGuess = [\n    tagCoordinates == null || tagCoordInvalid(tagCoordinates.x) ? \n    anchors.reduce((sum, [x]) => sum + x, 0) / anchors.length : \n    tagCoordinates.x,\n\n    tagCoordinates == null || tagCoordInvalid(tagCoordinates.y) ? \n    anchors.reduce((sum, [, y]) => sum + y, 0) / anchors.length : \n    tagCoordinates.y,\n    \n    tagCoordinates == null || tagCoordInvalid(tagCoordinates.z) ? \n    Math.max(...anchors.map(([, , z]) => z)) / 2 : \n    tagCoordinates.z,\n];\n\n\n\n// Configure options for the solver\nvar options = {\n    initialValues: initialGuess, // Initial guess for the parameters\n    damping: 1.5, // Regularization parameter for stability\n    maxIterations: 100, // Limit the number of iterations\n    errorTolerance: 0.01, // Stop when the error is below this threshold\n};\n\n// Prepare the input for the solver\nconst result = LM(\n    {\n        x: independentVars,\n        y: dependentVars,\n    },\n    modelFunction,\n    options\n);\n\n// Extract the best-fit parameters\nvar [bestX, bestY, bestZ] = result.parameterValues;\n\n// double check and see if the Z value makes sense, sometimes it converges above the actual height of the roof which doesn't make sense\nif(bestZ > 2.5 || bestZ < 0) {\n    // retry since the values don't make sense.\n    // set the values to our result, but reset the Z \n    initialGuess = [\n        bestX, bestY, 1.2\n    ]\n    options.initialValues = initialGuess;\n\n    const result = LM(\n        {\n            x: independentVars,\n            y: dependentVars,\n        },\n        modelFunction,\n        options\n    );\n\n    bestX = result.parameterValues.bestX;\n    bestY = result.parameterValues.bestY;\n    bestZ = result.parameterValues.bestZ;\n}\n\n\n\nconst TAG_ID = `dw1000-tag-${env.get(\"TAG_MAC\")}`;\n\n\n// Calculate residual error for diagnostics\nconst residuals = anchors.map(([ax, ay, az], index) => {\n    const predictedDistance = Math.sqrt(\n        (bestX - ax) ** 2 + (bestY - ay) ** 2 + (bestZ - az) ** 2\n    );\n    return Math.abs(predictedDistance - distances[index]);\n});\n\n// filter out outliers - deviation of more than 0.5m from previous if previous was valid\nif(!tagCoordInvalid(tagCoordinates.x) && tagCoordInvalid(tagCoordinates.y) && tagCoordInvalid(tagCoordinates.z) &&\n     Math.max(\n        Math.abs(tagCoordinates.x - bestX), \n        Math.abs(tagCoordinates.y - bestY),\n        Math.abs(tagCoordinates.z - bestZ)\n     ) > 0.5) {\n        return null;\n     }\n\n//node.warn(\"Residual errors (meters):\");\n//node.warn({ TAG_ID, bestX, bestY, bestZ, initialGuess, anchors, tagCoordinates, distances, residuals, msg})\n\n\nreturn [[\n{\n    topic: `homeassistant/sensor/${TAG_ID}-x/state`,\n    payload: { x: bestX}\n},\n    {\n        topic: `homeassistant/sensor/${TAG_ID}-y/state`,\n        payload: { y: bestY }\n    },\n    {\n        topic: `homeassistant/sensor/${TAG_ID}-z/state`,\n        payload: { z: bestZ }\n    },\n]]\n\n\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[{"var":"mlLevenbergMarquardt","module":"ml-levenberg-marquardt"}],"x":1420,"y":580,"wires":[["6be74b3cf8fc0785"]]},{"id":"4059ce48def35dfa","type":"server-state-changed","z":"e6d4f3856fb126d0","name":"If a distance changes","server":"b1ec8b7d.9fa258","version":6,"outputs":1,"exposeAsEntityConfig":"","entities":{"entity":[],"substring":[],"regex":["tag.*dist"]},"outputInitially":false,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":"0","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"","valueType":"triggerId"}],"x":280,"y":580,"wires":[["b6cca5690610775e"]]},{"id":"da0fc25e9f969d22","type":"inject","z":"e6d4f3856fb126d0","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":340,"y":500,"wires":[["b6cca5690610775e"]]},{"id":"6be74b3cf8fc0785","type":"mqtt out","z":"e6d4f3856fb126d0","name":"Update axis","topic":"","qos":"2","retain":"true","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"88162dc96fac86af","x":1670,"y":580,"wires":[]},{"id":"e76639ef87e83b38","type":"debounce-advanced","z":"e6d4f3856fb126d0","time":"250","timeunit":"ms","debouncetype":"leading","name":"","x":740,"y":580,"wires":[["2cb2b96cab6bcdf6"]]},{"id":"b1ec8b7d.9fa258","type":"server","name":"Home Assistant","addon":true},{"id":"88162dc96fac86af","type":"mqtt-broker","name":"Unraid","broker":"192.168.1.2","port":1883,"clientid":"","autoConnect":true,"usetls":false,"protocolVersion":4,"keepalive":60,"cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthRetain":"false","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closeRetain":"false","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willRetain":"false","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"fa62721e18c87829","type":"tab","label":"Flow 1","disabled":false,"info":"","env":[]},{"id":"0cb7872d42808133","type":"subflow:e6d4f3856fb126d0","z":"fa62721e18c87829","name":"Tag 80","env":[{"name":"TAG_MAC","value":"d83bda413580","type":"str"}],"x":810,"y":500,"wires":[]},{"id":"9ae4f251bbd5a8c3","type":"subflow:e6d4f3856fb126d0","z":"fa62721e18c87829","name":"Tag f8","env":[{"name":"TAG_MAC","value":"d83bda4141f8","type":"str"}],"x":810,"y":620,"wires":[]},{"id":"1bdf19f23297960f","type":"server-state-changed","z":"fa62721e18c87829","name":"tag coordinate changes","server":"b1ec8b7d.9fa258","version":6,"outputs":1,"exposeAsEntityConfig":"","entities":{"entity":[],"substring":[],"regex":["sensor.*(d83bda413580|d83bda4141f8)_(x|y|z)"]},"outputInitially":false,"stateType":"str","ifState":"","ifStateType":"str","ifStateOperator":"is","outputOnlyOnStateChange":true,"for":"0","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"","valueType":"triggerId"}],"x":460,"y":820,"wires":[["d6d41fd6cd0dd169"]]},{"id":"d6d41fd6cd0dd169","type":"debounce-advanced","z":"fa62721e18c87829","time":"1","timeunit":"s","debouncetype":"leading","name":"","x":690,"y":820,"wires":[["06837df34e99a3fc"]]},{"id":"06837df34e99a3fc","type":"ha-get-entities","z":"fa62721e18c87829","name":"","server":"b1ec8b7d.9fa258","version":1,"rules":[{"condition":"device_registry","property":"model","logic":"starts_with","value":"DW1000","valueType":"str"}],"outputType":"array","outputEmptyResults":false,"outputLocationType":"msg","outputLocation":"payload","outputResultsCount":1,"x":850,"y":820,"wires":[["75167ce5be92a5c3"]]},{"id":"75167ce5be92a5c3","type":"function","z":"fa62721e18c87829","name":"find angle between tag 80 and f8","func":"\nconst tagCoordsRaw = msg.payload.filter(e => e.entity_id.match(/sensor.*tag.*(d83bda4141f8|d83bda413580)_(x|y|z)/))\n\nconst tagCoords = tagCoordsRaw.reduce((acc, curr) => {\n    const id = curr.entity_id.slice(-14).slice(0,12);\n    const axis = curr.entity_id.slice(-1);\n    const val = Number(curr.state);\n    acc[id] = acc[id] == null ? {[axis]: val} : {...acc[id], [axis]: val};\n    return acc;\n}, {});\n\nfunction calculateAngle(entityA, entityB) {\n    // Extract coordinates\n    const dx = entityA.x - entityB.x;\n    const dy = entityA.y - entityB.y;\n\n    // Calculate the angle in radians relative to the positive Y-axis\n    const angleRadians = Math.atan2(dx, dy);\n\n    // Convert the angle to degrees\n    let angleDegrees = angleRadians * (180 / Math.PI);\n\n    // Ensure the angle is in the range [0, 360)\n    angleDegrees = (angleDegrees + 360) % 360;\n\n    return angleDegrees;\n}\n\nconst angle = calculateAngle(tagCoords.d83bda413580, tagCoords.d83bda4141f8)\n\n//ode.warn({msg, tagCoords, tagCoordsRaw, angle});\n\nreturn [[\n    {\n        topic: 'homeassistant/sensor/dw1000-tag-d83bda4141f8-angle/state',\n        payload: {angle}\n    },\n    {\n        topic: 'homeassistant/number/dw1000-tag-d83bda4141f8-angle/set',\n        payload: angle\n    }\n]]","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1120,"y":820,"wires":[["bea01b0c12dc2d87"]]},{"id":"bea01b0c12dc2d87","type":"mqtt out","z":"fa62721e18c87829","name":"Update axis","topic":"","qos":"2","retain":"true","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"88162dc96fac86af","x":1390,"y":820,"wires":[]}]